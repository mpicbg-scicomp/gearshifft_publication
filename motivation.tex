An FFT is a fast implementation of the discrete Fourier transform which is a standard text-book mathematical procedure. The forward transform is a mapping from an array $x$ of $n$ complex numbers in the time domain to an array $X$ of $n$ complex numbers in the frequency domain (also referred to as Fourier domain):
%
\newcommand{\iu}{{\mathrm{i}\mkern1mu}}
\begin{equation}
  \label{eq:dft}
  X[k] = \sum_{j=0}^{n-1} x[j]e^{\frac{-2\pi \iu jk}{n}}
\end{equation}
%
with $k$ being an integer index within $0 \le k < n$ and the imaginary unit $\iu^2{=}-1$. This operation was found to be computable in $\mathcal{O}(n \log n)$ complexity by Cooley-Turkey \cite{cooley1965algorithm}, which in turn rediscovered findings by Gauss \cite{gauss}. The basis of the Cooley-Turkey approach is the observation that, given the factorization of $n=n_1n_2$, the  DFT of size $n$ can be rewritten by smaller DFTs of size $n_1$ and $n_2$. Given the aforementioned indices $j=j_1n_2 + j_2$ and $k=k_1+k_2n_1$, \cref{eq:dft} can be re-expressed as:
%
\begin{equation}
  \label{eq:cooley-turkey}
  X[k_1{+}k_2n_1] = \sum_{j_2=0}^{n_2-1} \left( \left( \sum_{j_1=0}^{n_1-1} x[j_1n_2{+}j_2] e^{\frac{-2\pi \iu j_1k_1}{n_1}} \right) e^{\frac{-2\pi \iu j_2k_1}{n}} \right) e^{\frac{-2\pi \iu j_2k_2}{n_2}}
\end{equation}

\cref{eq:cooley-turkey} describes a decomposition that can be performed recursively \cite{FFTW05}. Here, $n_1$ is denoted \emph{radix} as it refers to $n_1$ transforms of size $n_2$. These smaller transforms are combined by a \emph{butterfly} graph with $n_2$ DFTs of size $n_1$ on the outputs of the corresponding sub-transforms. Radix-2 DFTs ($n$ being a power of two) are mostly implemented with the Cooley-Tukey algorithm \cite{cooley1965algorithm}. Stockham's formulations of the FFT can be applied \cite{stockham1966high} to avoid incoherent memory accesses. Arbitrary and mixed radices are more complicated and can be tackled with the prime-factorization or Chirp Z-transform implemented by the Bluestein's algorithm \cite{bluestein}. 

As \cref{eq:cooley-turkey} (similar to \cite{bluestein,stockham1966high}) can be considered a specialization of \cref{eq:dft}, the latter can be used to approximate the algorithmic complexity, i.e. a ratio of compute operations per accessed byte of memory. \cref{eq:dft} is a reduction of single- or double-precision floating point numbers \cite{ieee2008754}. A reduction of single-precision inputs on a fused multiply-add architecture (i.e. 1 addition and 1 multiplication in one instruction) would imply 1 operation per $\SI{4}{\byte}$ accessed and hence an arithmetic complexity of $1/4$ which would be a memory bound operation. As the exponentiation is not encoded into a single x86 instruction on any known architecture, it has to be expressed as a combination of \mc{FYL2X} and \mc{F2XM1}. On Intel Haswell, each of these instructions on scalar inputs consume at least $55\,\mu\text{ops}$ or $58\,\mu\text{ops}$ \cite{agnerfog} and it is hard if not impossible to estimate on paper how many cycles the entire exponentiation will consume. However, we can state that the exponentiation of floating point inputs will be compute bound. To summarize, this implies that \cref{eq:dft} and variations thereof will exhibit a compute bound performance profile where the cost of memory access is negligible (all required data is in the cache) and that this operation is memory bound elsewhere.  

Given the multitude of mathematical formulations and the heterogeneity of hardware, \gearshifft{} approaches the challenge of benchmarking a variety of FFT libraries from a user perspective. This means, that the following parameters shall be easy to study:

\begin{itemize}
\item FFT dimension and radix-type (e.g. $32{\times}32{\times}32$ as radix-2 3D FFT)
\item transform kinds, i.e. real-to-complex or complex-to-complex transforms
\item precision, i.e. 32-bit or 64-bit IEEE floating point number representation
\item memory mode
  \begin{itemize}
  \item \emph{in-place}: the input data structure is used for storing the output data (low memory footprint and low bandwidth are to be expected)
  \item \emph{out-of-place}:  where the transformed input is written to a different memory location than where the input resides (high memory footprint and high bandwidth are to be expected)
  \end{itemize}
\item transform direction, i.e. forward (from discrete space to frequency space) or backward (from frequency space to discrete space)
\end{itemize}
 
