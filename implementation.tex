
\subsection{Using a Modern FFT Library}
\label{ssec:modern_ffts}
Before discussing the design of \gearshifft{}, a brief introduction into the use and application programming interfaces (APIs) of modern FFT libraries is required to illustrate the design choices made.

Many FFT libraries today and moreover those used in this study base their API on \fftw{} $3.0$. First, a plan data structure has to be created and filled using a planner. For this, the FFT problem is defined in terms of rank (1D, 2D or 3D), shape of the input signal (the dimensional extent), type of the input signal (single or double precision of real or complex inputs), type of the transformation (real-to-complex, complex-to-complex, real-to-real) and memory mode of the transformation (inplace versus out-of-place). 

The parameters describing the FFT problem are then used as input to the planner. The planner is a piece of code inside \fftw{} that tries to find the best suited radix factorization based on the shape of the input signal. By default, it then performs several FFTs derived from the mathematical descriptions discussed in \cref{sec:motivation} on the input data to sample the runtime of different FFT implementations available inside \fftw{}. This ensemble of runtimes is then used to find the optimal FFT implementation to use. After the plan has been created, it is used to execute the FFT itself.

\begin{lstlisting}[caption={Minimal usage example of the \fftw{} single precision real-to-complex planner API. Memory management is omitted.},label={lst:fftw_example}]
int shape[] = {32,32,32};
fftw_plan r2c_plan = fftw_plan_dft_r2c(
  3,                       //rank, here 3D
  shape,                   //shape of the input
  (float *) input_buffer,  //input data array
  (fftwf_complex *) output,//output data array
  FFTW_ESTIMATE );         //plan-rigor flag
fftwf_execute(r2c_plan);
\end{lstlisting}

\cref{lst:fftw_example} illustrates the \fftw{} API for a single precision real-to-complex out-of-place transform. It is important to note that \fftw{} offers the freedom to choose the degree of optimization for finding the most optimal FFT implementation for the signal at hand by means of planner flag, also referred to as plan rigors. \cref{lst:fftw_example} uses the \texttt{FFTW\_ESTIMATE} flag as example, which is described by the \fftw{} manual \cite{fftw_manual} as:
%
\begin{quote}
``\texttt{FFTW\_ESTIMATE} specifies that, instead of actual measurements of different algorithms, a simple heuristic is used to pick a (probably sub-optimal) plan quickly. With this flag, the input/output arrays are not overwritten during planning.''
\end{quote}
%
\fftw{} offers five levels for this planning flag. As covering all of them in this study is impractical, we selected two more:
\begin{quote}
``\texttt{FFTW\_MEASURE} tells \fftw{} to find an optimized plan by actually computing several FFTs and measuring their execution time. Depending on your machine, this can take some time (often a few seconds).\newline
\texttt{FFTW\_WISDOM\_ONLY} is a special planning mode in which the plan is only created if wisdom is available for the given problem, and otherwise a NULL plan is returned.''
\end{quote}
%
In \fftw{} terminology, \emph{wisdom} is a data structure representing a more or less optimized plan for a given transform. The \texttt{fftw\_wisdom} binary which comes with the \fftw{} bundle generates hardware adapted wisdom files, which can be loaded by the wisdom API into any \fftw{} application.

The \cufft{} and \clfft{} follow this API mostly, only discarding the plan rigors and \emph{wisdom} infrastructure, see \cref{lst:cufft_example}.

\begin{lstlisting}[caption={Minimal usage example of the \cufft{} single precision real-to-complex planner API. Memory management is omitted.},label={lst:cufft_example}]
int N = 32;
cufftHandle plan;
cufftPlan3d(&plan, N, N, N, CUFFT_R2C);
cufftExecC2C(plan, input_buffer, output, CUFFT_FORWARD);
\end{lstlisting}
%
\subsection{The Architecture of \gearshifft{}}
\label{ssec:gearshifft_arch}
\gearshifft{} is developed as an open-source framework using C++ (following the 2014 ISO standard \cite{cpp14std}) and Boost Unit Test Framework (UTF, \cite{boost}). % for managing the tree of all the different benchmark cases.
One goal is to have a unified benchmark infrastructure and an extensible set of FFT library clients. 
These clients implement a given interface which is used by the benchmark framework. 
The benchmark framework is independent of the used FFT library and provides the measuring environment, data handling and processing of results.
Furthermore, by following that interface comparable results shall be obtained.
Such a benchmark framework could be realized with inheritance or with template meta-programming. 
We have chosen template meta-programming with a compile-time constant, implicit interface between the clients and benchmark framework.
This yields minimal overhead at runtime and provides a type-agnostic interface, i.\,e. \gearshifft{} is not fixed to single or double precision.

% \begin{lstlisting}[caption={Context class required by gearshifft front-end API},label={lst:implcontext}]
% struct Context {
%   /// title for all benchmarks associated with this context
%   static std::string title();
%   /// list all compute devices with their IDs
%   static std::string get_device_list();
%   /// information of current device
%   std::string get_used_device_properties();
%   void create();  // create context
%   void destroy(); // destroy context
% };
% \end{lstlisting}

The front-end interface requires the user to implement the context class and an FFT client class. The API documentation can be found online \cite{gearshifft_github}, but we want to discuss the most relevant features in the following. The context methods \mc{create} and \mc{destroy} are for time-consuming device and library initialization, if it does not store plan information as \fftw{} does. These methods are measured separately and run only once. 

\begin{lstlisting}[caption={Required template arguments for FFT client implementation},label={lst:implfft_templ}]
template<
 typename TFFT,       // e.g. gearshifft::FFT_Inplace_Real, ...
 typename TPrecision, // e.g. double, float, ...
 size_t   NDim        // 1,..,3
 /* .. further template types if needed .. */
>
struct MyFFTClient;
\end{lstlisting}

\begin{table}[tb]
\centering
\caption{Methods FFT client has to implement}\label{tab:implfft}
\setlength{\tabcolsep}{12pt}
\begin{tabular}{*{3}{c}}
  \toprule
  \mc{constructor} & \mc{get_alloc_size}    & \mc{execute_forward} \\
  \mc{destructor}  & \mc{get_transfer_size} & \mc{execute_inverse} \\
  \mc{allocate}    & \mc{get_plan_size}     & \mc{upload} \\
  \mc{destroy}     & \mc{init_forward}      & \mc{download} \\
                   & \mc{init_inverse}      & \\
  \bottomrule
 \end{tabular}
\end{table}

The FFT client implementation class in \cref{lst:implfft_templ} is instantiated once per benchmark run and follows the {\textit{resource allocation is initialization}} (RAII) idiom \cite{stroustrup1994design}. \gearshifft{} invokes FFT client methods as listed \cref{tab:implfft} to perform the benchmarks and populate the benchmark data. The FFT client can assign user-defined template types to create different FFT client classes to mimic various use cases. An example is given by the \fftw{} implementation, which involves a compile-time constant configuration structure to map plan rigors like \mc{FFTW_MEASURE} or \mc{FFTW_ESTIMATE} into the aforementioned FFT client classes.

Depending on the FFT library, after a forward transform the same plan handle might be recreated for backward transform. This saves memory as there is only one plan allocated at any point in time and, for example, the GPU FFT libraries allocate memory for the plan on the device. \fftw{} can overwrite input and output buffers during the planning phase, when e.g. \mc{FFTW_MEASURE} is used. Afterwards, the buffers can be filled with data. In turn, this plan handle cannot be recreated later on, as the result buffer of the previous plan would be overwritten at plan recreation. In this case, the plans are allocated before the round-trip FFT starts.

The \gearshifft{} interface also allows to use library-specific time measurements, which is only implemented for the \cufft{} library at the moment, where CUDA event-based timers are used. For \fftw{} and \clfft{}, the CPU timer exposed by the C++14 \mc{chrono} header is used.

\begin{lstlisting}[caption={Define FFT client types for corresponding FFTs},label={lst:implfftusing}]
namespace MyFFT { 
  using Inplace_Real = gearshifft::FFT<
   gearshifft::FFT_Inplace_Real, MyFFTClient, TimerCPU >;
// ...
}
\end{lstlisting}

\cref{lst:implfftusing} shows a type definition for the user implemented class \mc{MyFFTClient} and specifies an inplace-real transformation (cp. \cref{lst:implfft_templ}).
This type is added to a list for the benchmark runner, as demonstrated in \mc{benchmark.cpp} (\cref{lst:implfftusingp2}). The \mc{gearshifft::List} is a compile-time constant list, which holds the different template instantiations of an FFT client. \mc{FFT_Is_Normalized} denotes a compile time flag if the backward transformed data needs to be normalized in order to achieve identity with the input.

\begin{lstlisting}[caption={Using FFT client types to run the benchmarks},label={lst:implfftusingp2}]
using namespace gearshifft;
using Context           = MyFFT::Context;         
using FFTs              = List<MyFFT::Inplace_Real>;
using Precisions        = List<float, double>;   
using FFT_Is_Normalized = std::false_type;
int main( int argc, char* argv[] ) {                                                        
  try {                                                  
    Benchmark<Context> benchmark;
    benchmark.configure(argc, argv);                     
    benchmark.run<FFT_Is_Normalized, FFTs, Precisions>();
  } catch(const std::runtime_error& e) {
    std::cerr << e.what() << std::endl;                  
    return 1;                                            
  }                                                      
  return 0; }                                                        
\end{lstlisting}

For each benchmark configuration, a number of benchmark repetitions is performed to allow reliable statistical analysis. This is currently defined as compile-time constant in \mc{Application::NR_RUNS=5}. After a benchmark has been completed, the round-trip transformed data is validated against the original input data. If a mismatch is present, the benchmark is marked as failed and \gearshifft{} continues with the next configuration in the benchmark tree. The error bound used for this error check is defined by \mc{Application::ERROR_BOUND=0.00001}. 

A \gearshifft{} benchmark is defined in the back-end. It is meant to collect performance indicators of a set of operations defining implicitly the interface for the FFT clients. Different parameters like precision, FFT extents, transform variant, device type or FFT library relate to different benchmarks.
\gearshifft{} controls many of them by command line arguments. The FFT libraries are related to different \gearshifft{} binaries (\mc{gearshifft_cufft}, \ldots).
The back-end of \gearshifft{} uses Boost Unit Test Framework to generate the benchmark instances.

The measurement layout and benchmark framework is illustrated in \cref{fig:framework}. One single run comprises time measurement of each operation (allocate, init forward, \ldots). The total time measures all from \mc{allocate} to \mc{destroy}. Furthermore, the memory footprint of the FFT client is recorded. The functor \mc{FFT} calls the FFT client operations wrapped with time measurements. The input data buffer is held by \mc{BenchmarkExecutor} and a copy is given to the \mc{FFT} functor in each run.

% implies plan reuse
\begin{figure}[t]
\centering
%align=center,rounded corners,inner sep=5pt,rectangle,draw,
\tikzset{class/.style={inner sep=5pt,font=\footnotesize}}
\newcommand{\pclass}[5][]{
\ifthenelse { \equal {#1} {} }
 {\node[class] (#5) at (#3,#4) {#2};}
 {\node[class] (#5) at (#3,#4) {%
\begin{tabular}{c}\scriptsize{<<#1>>}\\#2\end{tabular}%
};}
}
\begin{tikzpicture}
\tikzset{gr1/.style={fill=black!15}}
\tikzset{bts/.style={draw,circle,inner sep=2pt}}
\tikzset{btc/.style={draw,circle,inner sep=2pt,fill=black}}
%
\begin{scope}[yshift=3.5cm,xshift=-2.9cm]
\node[bts] (b0) at (0,0) {};
\node[bts] (b10) at (-0.5,-0.6) {}; \draw (b10) -- (b0);
\node[bts] (b11) at (0.5,-0.6) {}; \draw (b11) -- (b0);
\node[btc] (b20) at (-0.75,-1.3) {}; \draw (b20) -- (b10);
\node[btc] (b21) at (-0.25,-1.3) {}; \draw (b21) -- (b10);
\node[btc] (b22) at ( 0.25,-1.3) {}; \draw (b22) -- (b11);
\node[btc] (b23) at ( 0.75,-1.3) {}; \draw (b23) -- (b11);
\node[font=\scriptsize] at (0, 0.3) {Boost Test Suites};
\node[font=\scriptsize] at (0,-1.7) {Boost Test Cases};
\end{scope}
% \begin{scope}[yshift=4cm,xshift=-6cm,every node/.style={anchor=west,align=left,font=\scriptsize}]
% \node at (0,0) {cuFFT};
% \node at (0,-0.5) {float};
% \node at (0,-1) {1024x1024};
% \node at (0,-1.5) {Inplace\_Real};
% \end{scope}

% 
\begin{scope}[xshift=1.75cm]
\begin{scope}
\pclass{Benchmark}{-2}{4}{b}
\pclass[Functor]{BenchmarkSuite}{-2}{3.2}{bs}
\pclass[Functor]{BenchmarkExecutor}{-2}{2.1}{be}
\pclass[Functor]{FFT}{-2}{1.0}{fft}
\end{scope}
\begin{scope}
\pclass[Singleton]{Application}{1.5}{4}{app}
\pclass[Realisation]{Context}{1.5}{2.5}{ctx}
\pclass[Realisation]{FFTClient}{1.5}{1.1}{impl}
\end{scope}
\end{scope}
\matrix[
 minimum height=1.5em,
 matrix of nodes,
 row sep=-\pgflinewidth,
 column sep=-\pgflinewidth,
 text depth=2.5ex,
 text height=1.5ex,
 text width=3.6em,
 align=center,
 nodes in empty cells,
 row 1/.style={nodes={rectangle,draw,minimum width=3em,font=\scriptsize\itshape}}
]
(mf) at (0,0) {
allocate &
init\linebreak forward &
|[gr1]| upload &
|[gr1]| execute\linebreak forward &
init\linebreak inverse &
|[gr1]| execute\linebreak inverse &
|[gr1]| download &
destroy\\
};
\draw (mf-1-1.north west) ++(-0.75em,0.5em) coordinate (ctl) -- ([xshift=0.75em,yshift=0.5em]mf-1-8.north east) coordinate (cr);
\draw[dotted] (ctl) -- ++(-2ex,0); \draw[dotted] (cr) -- ++(2ex,0);
\draw (mf-1-1.south west) ++(-0.75em,-0.5em) coordinate (cl) -- ([xshift=0.75em,yshift=-0.5em]mf-1-8.south east) coordinate (cr);
\draw[dotted] (cl) -- ++(-2ex,0); \draw[dotted] (cr) -- ++(2ex,0);
% total time
\draw[thick,dashed,|-|] (mf-1-1.south west) ++(0,-1.5em) -- ([yshift=-1.5em]mf-1-8.south east) node[pos=0.5,fill=white,font=\small\itshape] {total time};
% (mf-1-1.south west) -- ++(0,-1.5em) -| (mf-1-8.south east) node[pos=0.25,fill=white,font=\small] {total time};

% \draw[-latex] (b) -- (bs);
% \draw[-latex] (fft) -- (ctl-|fft);
\draw[black!50] (b.south west) -- (b.south east);
\draw[black!50] (bs.south west) -- (bs.south east);
\draw[black!50, dashed] (bs.south west) -- ++(-8em,0); % test suite marker
\draw[black!50] (be.south west) -- (be.south east);

\draw[densely dashed,-angle 60] (app) -- (ctx);
\draw[-angle 60] (b) -- (app.west|-b);
% \draw[densely dashed,-angle 90] (be.east) -| (impl.north);
% \draw[densely dashed,-open triangle 60] (impl) -- (fft.east|-impl) node[midway] (q) {};
\draw[densely dashed,-angle 90] (fft) -- (impl.west|-fft) node[midway] (q) {};
\draw[densely dashed] (q) -- (ctl-|q);
\end{tikzpicture}
 \caption{The benchmark framework of \gearshifft{} using Boost UTF and a realized FFT interface; Here, only FFT interfaces are shown, that are measured (gray operations are measured by device timers if provided); Context also has an implicit interface, which is omitted here.}
 \label{fig:framework}
\end{figure}

Currently, \gearshifft{} supports three different FFT libraries, \cufft{} (CUDA runtime, \cite{nvidia2010cufft}) for \nvidia{} GPUs, \clfft{} (OpenCL runtime, \cite{clfft}) for CPU and GPUs and \fftw{} for CPU (C/C++ runtime, \cite{FFTW05}). By this selection, an accelerator-only, a mixed CPU-GPU and a CPU-optimized library is covered.
%
We use \texttt{cmake} as build system to setup build paths to construct one executable for each supported FFT libraries found by \texttt{cmake} as well as for collecting the include paths during the build process and library locations for linking later on. There are options for disabling FFT libraries or pointing to non-standard installation paths and to configure compile-time constants such as the \fftw{} planning time limit. 

For the command-line arguments Boost is utilized, particularly for benchmark lists and selection.
There are several \gearshifft{} program options to control benchmark settings, where an example would be:
\begin{lstlisting}[language=bash]
gearshifft_clfft -e 16,16 8x8x8 -r */float/*/Inplace_Real -d cpu
\end{lstlisting}
Here, the \clfft{} benchmarks would be invoked on an $8\times8\times8$ input array as well as a $16\times16$ input array of single-precision each, performing with real-to-complex / complex-to-real transforms.
The default setting implies to use all CPU cores and to store the results into result.csv. The \gearshifft{} benchmark selection syntax supports wildcards. The first wildcard \mc{*} relates to the title of the FFT client (\mc{ClFFT} in this example). The second one refers to the extents.
