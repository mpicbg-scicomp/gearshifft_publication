
% - [open source] framework: c++14 with help of boost
% - demonstrate usage of gearshifft framework
% - cufft, clfft, fftw
% - issues?
% - #runs, cmake, project structure
% - libraries : mem checks
\gearshifft{} is developed as an open-source framework using C++ (following the 2014 ISO standard \cite{cpp14std}) and Boost Unit Test Framework (UTF, \cite{boost}) for managing the tree of all the different benchmark cases.

\subsection{Using a Modern FFT Library}
\label{ssec:modern_ffts}

Before discussing the design of \gearshifft{}, a brief introduction into the use and application programming interfaces (APIs) of modern FFT libraries is required to illustrate the design choices made.

Many FFT libraries today and moreover those used in this study base their architecture and API on \fftw{} $3.0$. There are typical interactions that any client to \fftw{} has to perform in order to execute an FFT on signal data. First a plan data structure has to be created and filled using a planner. For this, the FFT problem is defined in terms of rank (1D, 2D or 3D), shape of the input signal, type of the input signal (single or double precision of real or complex inputs), type of the transformation (real-to-complex, complex-to-complex, real-to-real) and memory mode of the transformation (inplace versus out-of-place). The FFT problem description is then used as input parameters to the planner. The planner is a piece of code inside \fftw{} that henceforth tries to find the best suited radix factorization based on the shape of the input signal. It then performs several FFTs on the input data to sample the runtime of different FFT implementations available inside \fftw{}. The sample of runtimes is then used to find the optimal implementation of the FFT. After the plan has been created, it is used to execute the FFT itself.
Depending on the number of plan executions one should spend certain amount of time in the planning phase to minimize planning and execution times altogether.
\begin{lstlisting}[caption={Minimal usage example of the \fftw{} single precision real-to-complex planner API. Memory management is omitted.},label={lst:fftw_example}]
int shape[] = {32,32,32};
fftw_plan r2c_plan = fftw_plan_dft_r2c(
  3,                       //rank, here 3D
  shape,                   //shape of the input
  (float *) input_buffer,  //input data array
  (fftwf_complex *) output,//output data array
  \fftw{}_ESTIMATE );         //plan-rigor flag
fftwf_execute(r2c_plan);
\end{lstlisting}
\cref{lst:fftw_example} illustrates the \fftw{} API for a single precision real-to-complex out-of-place transform. It is important to note that \fftw{} offers the user the freedom to choose the degree of optimization for finding the most optimal FFT implementation for the signal at hand. \cref{lst:fftw_example} uses the \texttt{\fftw{}\_ESTIMATE} flag, which is described by the \fftw{} manual \cite{fftw_manual} as:
%
\begin{quote}
``\texttt{\fftw{}\_ESTIMATE} specifies that, instead of actual measurements of different algorithms, a simple heuristic is used to pick a (probably sub-optimal) plan quickly. With this flag, the input/output arrays are not overwritten during planning.''
\end{quote}
%
Fftw offers five levels for this planning flag in total. As covering all of them in this study is impractical, we selected two more:
\begin{quote}
``\texttt{\fftw{}\_MEASURE} tells \fftw{} to find an optimized plan by actually computing several FFTs and measuring their execution time. Depending on your machine, this can take some time (often a few seconds).\newline
\texttt{\fftw{}\_WISDOM\_ONLY} is a special planning mode in which the plan is only created if wisdom is available for the given problem, and otherwise a NULL plan is returned.''
\end{quote}
%
In \fftw{} terminology, wisdom is a persistent data structure that \texttt{fftw\_wisdom} binary in the \fftw{} install tree can generate. It is meant to allow users to generate the plan for specific input data shapes offline to their application. The stored 'wisdom' can then be read from disk through the \fftw{} wisdom API.
The studied GPU based FFT implementations follow this design structure without the plan-rigor flags and wisdoms however, see \cref{lst:cufft_example}.
\begin{lstlisting}[caption={Minimal usage example of the cuFFT single precision real-to-complex planner API. Memory management is omitted.},label={lst:cufft_example}]
int N = 32;
cufftHandle plan;
cufftPlan3d(&plan, N, N, N, CUFFT_R2C);
cufftExecC2C(plan, input_buffer, output, CUFFT_FORWARD);
\end{lstlisting}
%
\subsection{The Architecture of \gearshifft{}}
\label{ssec:gearshifft_arch}

The frontend API is basically a wrapper for the FFT client operations like plan initialization, forward or backward transformation which are motivated in \cref{sec:motivation}.
The interface for the FFT client is designed to integrate any given FFT library, that provides forward and backward Fourier transforms.
The wrapper code leverages C++ templates and the meta-programming language for compile-time constant expressions.
This yields minimal overhead at runtime and provides a type-agnostic interface, i.\,e. \gearshifft{} is not fixed to single or double precision.
However, the benchmark runtime environment allocates memory for samples and performance data.

\begin{lstlisting}[caption={Context class required by gearshifft frontend API},label={lst:implcontext}]
struct Context {
  /// title for all benchmarks associated with this context
  static std::string title();
  /// list all compute devices with their IDs
  static std::string get_device_list();
  /// information of current device
  std::string get_used_device_properties();
  void create();  // create context
  void destroy(); // destroy context
};
\end{lstlisting}

The frontend interface requires the user to implement the context class and a class with methods for the FFT client routines.
The context class in \cref{lst:implcontext} is instantiated only once for the application lifetime.
FFT libraries like clFFT have a global setup routine, which should not be invoked in each benchmark for the sake of performance and proper measurements. 
The context functions \mc{create} and \mc{destroy} are run only once and are measured separately.
This speeds up the whole benchmark as device and library initialization might be quite time-consuming. 
By \mc{Application<Context>::getContext()} the user has access to the global context instance.

\begin{lstlisting}[caption={Required template arguments for FFT client implementation},label={lst:implfft_templ}]
template<
 typename TFFT, // e.g. gearshifft::FFT_Inplace_Real, ...
 typename TPrecision, // e.g. double, float, ...
 size_t   NDim        // 1,..,3
 /* .. further template types if needed .. */
>
struct MyFFTClient { // ...
\end{lstlisting}
%   FFT_Client_Impl();
%   ~FFT_Client_Impl();
%   void allocate();
%   size_t getAllocSize();
%   size_t getTransferSize();
%   size_t getPlanSize();
%   void init_forward();
%   void init_inverse();
%   void execute_forward();
%   void execute_inverse();
%   template<typename THostData>
%   void upload(THostData* input);
%   template<typename THostData>
%   void download(THostData* output);
%   void destroy();

\begin{table}[ht]
\centering
\caption{FFT client implementation required by gearshifft frontend API}\label{tab:implfft}
\begin{tabular}{*{3}{p{0.3\textwidth}}}
  \toprule
  \mc{constructor} & \mc{get_alloc_size}    & \mc{execute_forward} \\
  \mc{destructor}  & \mc{get_transfer_size} & \mc{execute_inverse} \\
  \mc{allocate}    & \mc{get_plan_size}     & \mc{upload} \\
  \mc{destroy}     & \mc{init_forward}      & \mc{download} \\
                   & \mc{init_inverse}      & \\
  \bottomrule
 \end{tabular}
\end{table}

The FFT client implementation class in \cref{lst:implfft_templ} is instantiated once per benchmark run and follows the ``resource allocation is initialization (RAII) pattern.
All the data allocated in instantiation must be freed on destruction, otherwise memory leaks can have significant impact on benchmark results.
The methods listed in \cref{tab:implfft} are invoked by \gearshifft{} and must be implemented by the user.
The FFT client implementation can assign user-defined template types to create different FFT client classes to mimic different use cases. An example is given by the \fftw{} implementation, which involves a compile-time constant configuration structure to map plan-rigors like \mc{\fftw{}_MEASURE} or \mc{\fftw{}_ESTIMATE}.

\begin{lstlisting}[caption={FFT wrapper class},label={lst:fftabstract}]
template<
 typename T_FFT, // e.g. FFT_Inplace_Real ..
 typename T_ReusePlan, // can plan be reused ?
 template <typename,typename,size_t,typename... > typename T_Client,
 typename T_DeviceTimer,
 typename... T_ClientArgs >
struct FFT : public T_FFT {
  template<typename T_Result, typename T_Vector, size_t NDim>
  void operator(/*..*/);
};
\end{lstlisting}

The wrapper for the FFT client and the layout of measurement is implemented in the \mc{gearshifft::FFT} functor.
Its template parameters are shown in \cref{lst:fftabstract}. 
The template parameter \mc{T_FFT} is assigned with one of the predefined types \mc{FFT_Inplace_Real}, \mc{FFT_Outplace_Real}, \mc{FFT_Inplace_Complex} and \mc{FFT_Outplace_Complex}.

Most libraries allow plan reuse.
Reusing a plan means to use only one plan handle. After forward transform has been finished the same plan handle is used for backward transform.
This might save memory as there are no two plans allocated at the same time. \fftw{} already overwrites input and output buffer in the planning phase, when \mc{\fftw{}_MEASURE} is used. Afterwards, the buffers can be filled with data, but it means, that the plan cannot be reused at a later time, since the result buffer of the previous plan would be overwritten at the second planning stage.
Thus, when it is not possible to reuse the plan handle, then plan handles for forward and inverse transform are allocated in the initialization phase.
%
\mc{T_Client} defines the FFT client class like \mc{CuFFTImpl} or \mc{FftwImpl}.
The template parameters are at least the \mc{T_FFT} type (\mc{FFT_Inplace_Real}, \ldots), the precision type (float, \ldots) and the FFT dimension (1, 2 or 3). 
If the client needs more template arguments the variadic template \mc{T_ClientArgs} is given to the \mc{T_Client} instantiation as fourth parameter (expansion of a parameter pack).
The \mc{T_DeviceTimer} allows device-specific time measurements and is only implemented for CUDA/cuFFT library at the moment.

\begin{lstlisting}[caption={Define FFT client types for corresponding FFTs},label={lst:implfftusing}]
namespace MyFFT { 
// ...
  using Inplace_Real = gearshifft::FFT<
   gearshifft::FFT_Inplace_Real, MyFFTClient, TimerCPU >;
}
\end{lstlisting}

Finally, the FFT client and the FFT wrapping functor are combined in \cref{lst:implfftusing} to obtain the type at compile-time, which is invoked in benchmark.cpp as \cref{lst:implfftusingp2} illustrates. The \mc{gearshifft::List} is a compile-time constant list, which holds the different template instantiations of the FFT client. 

\begin{lstlisting}[caption={Using FFT client types to run the benchmarks},label={lst:implfftusingp2}]
using namespace gearshifft;
using Context           = MyFFT::Context;         
/// meta list can be extended with further types
using FFTs              = List<MyFFT::Inplace_Real>;
using Precisions        = List<float, double>;   
/// do not divide iFFT(FFT(x)) by number of elements
using FFT_Is_Normalized = std::false_type;
int main( int argc, char* argv[] ) {                                                        
  try {                                                  
    Benchmark<Context> benchmark;
    benchmark.configure(argc, argv);                     
    benchmark.run<FFT_Is_Normalized, FFTs, Precisions>();
  } catch(const std::runtime_error& e) {
    std::cerr << e.what() << std::endl;                  
    return 1;                                            
  }                                                      
  return 0;
}                                                        
\end{lstlisting}

The number of benchmark repetitions is currently defined as compile-time constant in \mc{Application::NR_RUNS=5}, which will be changed to a runtime flag in a future release.
The same holds for the error bound \mc{Application::ERROR_BOUND=0.00001}. After a benchmark has been completed, the roundtrip transformed data is validated against the original input data. If a mismatch is present, the benchmark is marked as failed and \gearshifft{} continues with the next configuration in the benchmark tree.

Now after the frontend API has been introduced, the backend of \gearshifft{} is discussed.
% definition might be moved into former section
A benchmark is defined to collect performance indicators of a set of operations, and repeats the execution several times to obtain reliable statistics. Different parameters like precision, FFT extents, transform variant, device type or FFT library relate to different benchmarks.
\gearshifft{} controls many of them by command line arguments (\cref{tab:cmdargs}). The FFT libraries are related to different \gearshifft{} binaries (\mc{gearshifft_cufft}, \ldots).
The backend of \gearshifft{} uses Boost Unit Test Framework to generate the benchmark instances. % @todo ref
%
The measurement layout and benchmark framework is illustrated in \cref{fig:framework}.
One single run comprises time measurement of each operation (allocate, \ldots). 
%allocate, init forward, upload, execute forward, init inverse, execute inverse, download and destroy
The total time measures from \mc{allocate} over forward and inverse transforms to \mc{destroy}.
Furthermore, the memory footprint of the FFT client is recorded to answer the question, which FFT library consumes minimal memory.
%i.\,e. the FFT client \mc{T_Client} is intantiated to run its operations for plan generation, FFTs and data management.

The functor \mc{FFT} contains the FFT client operations wrapped with time measurements. The input data buffer is hold by \mc{BenchmarkExecutor} and a copy is given to the \mc{FFT} functor each run.

% implies plan reuse
\begin{figure}[t]
\centering
%align=center,rounded corners,inner sep=5pt,rectangle,draw,
\tikzset{class/.style={inner sep=5pt,font=\footnotesize}}
\newcommand{\pclass}[5][]{
\ifthenelse { \equal {#1} {} }
 {\node[class] (#5) at (#3,#4) {#2};}
 {\node[class] (#5) at (#3,#4) {%
\begin{tabular}{c}\scriptsize{<<#1>>}\\#2\end{tabular}%
};}
}
\begin{tikzpicture}
\tikzset{gr1/.style={fill=black!15}}
\tikzset{bts/.style={draw,circle,inner sep=2pt}}
\tikzset{btc/.style={draw,circle,inner sep=2pt,fill=black}}
%
\begin{scope}[yshift=3.5cm,xshift=-2.9cm]
\node[bts] (b0) at (0,0) {};
\node[bts] (b10) at (-0.5,-0.6) {}; \draw (b10) -- (b0);
\node[bts] (b11) at (0.5,-0.6) {}; \draw (b11) -- (b0);
\node[btc] (b20) at (-0.75,-1.3) {}; \draw (b20) -- (b10);
\node[btc] (b21) at (-0.25,-1.3) {}; \draw (b21) -- (b10);
\node[btc] (b22) at ( 0.25,-1.3) {}; \draw (b22) -- (b11);
\node[btc] (b23) at ( 0.75,-1.3) {}; \draw (b23) -- (b11);
\node[font=\scriptsize] at (0, 0.3) {Boost Test Suites};
\node[font=\scriptsize] at (0,-1.7) {Boost Test Cases};
\end{scope}
% \begin{scope}[yshift=4cm,xshift=-6cm,every node/.style={anchor=west,align=left,font=\scriptsize}]
% \node at (0,0) {cuFFT};
% \node at (0,-0.5) {float};
% \node at (0,-1) {1024x1024};
% \node at (0,-1.5) {Inplace\_Real};
% \end{scope}

% 
\begin{scope}[xshift=1.75cm]
\begin{scope}
\pclass{Benchmark}{-2}{4}{b}
\pclass[Functor]{BenchmarkSuite}{-2}{3.2}{bs}
\pclass[Functor]{BenchmarkExecutor}{-2}{2.1}{be}
\pclass[Functor]{FFT}{-2}{1.0}{fft}
\end{scope}
\begin{scope}
\pclass[Singleton]{Application}{1.5}{4}{app}
\pclass[Realisation]{Context}{1.5}{2.5}{ctx}
\pclass[Realisation]{FFTClient}{1.5}{1.1}{impl}
\end{scope}
\end{scope}
\matrix[
 minimum height=1.5em,
 matrix of nodes,
 row sep=-\pgflinewidth,
 column sep=-\pgflinewidth,
 text depth=2.5ex,
 text height=1.5ex,
 text width=3.6em,
 align=center,
 nodes in empty cells,
 row 1/.style={nodes={rectangle,draw,minimum width=3em,font=\scriptsize\itshape}}
]
(mf) at (0,0) {
allocate &
init\linebreak forward &
|[gr1]| upload &
|[gr1]| execute\linebreak forward &
init\linebreak inverse &
|[gr1]| execute\linebreak inverse &
|[gr1]| download &
destroy\\
};
\draw (mf-1-1.north west) ++(-0.75em,0.5em) coordinate (ctl) -- ([xshift=0.75em,yshift=0.5em]mf-1-8.north east) coordinate (cr);
\draw[dotted] (ctl) -- ++(-2ex,0); \draw[dotted] (cr) -- ++(2ex,0);
\draw (mf-1-1.south west) ++(-0.75em,-0.5em) coordinate (cl) -- ([xshift=0.75em,yshift=-0.5em]mf-1-8.south east) coordinate (cr);
\draw[dotted] (cl) -- ++(-2ex,0); \draw[dotted] (cr) -- ++(2ex,0);
% total time
\draw[thick,dashed,|-|] (mf-1-1.south west) ++(0,-1.5em) -- ([yshift=-1.5em]mf-1-8.south east) node[pos=0.5,fill=white,font=\small\itshape] {total time};
% (mf-1-1.south west) -- ++(0,-1.5em) -| (mf-1-8.south east) node[pos=0.25,fill=white,font=\small] {total time};

% \draw[-latex] (b) -- (bs);
% \draw[-latex] (fft) -- (ctl-|fft);
\draw[black!50] (b.south west) -- (b.south east);
\draw[black!50] (bs.south west) -- (bs.south east);
\draw[black!50, dashed] (bs.south west) -- ++(-8em,0); % test suite marker
\draw[black!50] (be.south west) -- (be.south east);

\draw[densely dashed,-angle 60] (app) -- (ctx);
\draw[-angle 60] (b) -- (app.west|-b);
% \draw[densely dashed,-angle 90] (be.east) -| (impl.north);
% \draw[densely dashed,-open triangle 60] (impl) -- (fft.east|-impl) node[midway] (q) {};
\draw[densely dashed,-angle 90] (fft) -- (impl.west|-fft) node[midway] (q) {};
\draw[densely dashed] (q) -- (ctl-|q);
\end{tikzpicture}
 \caption{The benchmark framework of \gearshifft{} using Boost UTF and a realized FFT interface; Here, only FFT interfaces are shown, that are measured (gray operations are measured by device timers if provided); Context also has an implicit interface, which is omitted here.}
 \label{fig:framework}
\end{figure}

Currently, \gearshifft{} comes with three different FFT libraries, namely cuFFT (CUDA) for nVidia GPUs \cite{nvidia2010cufft}, clFFT (OpenCL) from AMD \cite{clfft} and \fftw{} \cite{\fftw{}05}.
% cuFFT is NVIDIA CUDA GPU-only using the Cooley-Tukey and Bluestein algorithms \cite{cooley65,bluestein}.
% clFFT implements a variation of Cooley-Tukey and Stockham algorithm in OpenCL to run on heterogeneous platforms.
% \fftw{} is CPU-only and primarily uses Cooley-Tukey supporting various SIMD (SSE, AVX, \ldots) optimizations.
By this selection, an accelerator-, mixed and a CPU-optimized library is covered.
%
As build system we use \texttt{cmake} to configure the includes and the executables according to the FFT libraries found by \texttt{cmake} in the user environment. There are options\footnote{Use \mc{ccmake .} in the build directory for customizing the settings.} for disabling FFT libraries or \fftw{} planning time limit.
%The project structure is depicted in \cref{fig:projstruct}.
The common build procedure is to use a build directory (release, debug) for makefile generation with \mc{cmake ..}.
%
%% \begin{figure}[!htp]
%%   \centering
%% \begin{tikzpicture}
%% \begin{scope}[grow via three points={one child at (0.4,-0.4) and
%%   two children at (0.4,-0.4) and (0.4,-0.8)},
%%   edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)},
%%   every node/.style={anchor=west,font=\ttfamily}%
%% ]
%% \node {gearshifft}
%%     child { node (cfg) {config}}		
%%     child { node (inc) {inc}
%%       child { node (core) {core}}
%%       child { node (lib) {libraries}}
%%     }
%%     child [missing] {}				
%%     child [missing] {}
%%     child { node (scripts) {scripts}}
%%     child { node (src) {src}}; 
%% \end{scope}
%% \begin{scope}[every node/.style={anchor=west}]
%% \coordinate (d) at (4.1,0);
%% \draw[dotted] (cfg) -- (cfg-|d) node { config files for extents (extents.csv, \ldots)};
%% \draw[dotted] (inc) -- (inc-|d) node { header files};
%% \draw[dotted] (core) -- (core-|d) node { gearshifft core headers (benchmark.hpp, \ldots};
%% \draw[dotted] (lib) -- (lib-|d) node { FFT client directories with headers (fftw/fftw.hpp, \ldots)};
%% \draw[dotted] (scripts) -- (scripts-|d) node { python scripted config generator};
%% \draw[dotted] (src) -- (src-|d) node { gearshifft source files (benchmark.cpp, options.cpp)}; 
%% \end{scope}
%% \end{tikzpicture}
%%  \caption{gearshifft project structure.}
%%  \label{fig:projstruct}
%% \end{figure}

%% \vspace{-2em}

\begin{table}[htp]
 \centering
 \caption{gearshifft command-line arguments}
 \label{tab:cmdargs}
  \begin{tabular}{llp{6.4cm}}
\toprule
Flag & [Flag] Argument & Description \\
\midrule
-h&[ -{}-help ]                    &Print help messages \\
-e&[ -{}-extent ] arg              &Specific extent (eg. 1024x1024)\newline[$\ge1$ 
                                  arguments possible] \\
-f&[ -{}-file ] arg                &File with extents (row-wise csv)\newline[$\ge1$ 
                                  arguments possible] \\
-o&[ -{}-output ] arg (=result.csv)&Output csv file, will be overwritten! \\
-v&[ -{}-verbose ]                 &Show statistics after benchmarks finished \\
-d&[ -{}-device ] arg (=gpu)       &Compute device = (gpu|cpu|acc|<ID>). If 
                                  device is not supported by FFT lib, then it
                                  is ignored and default is used. \\
-n&[ -{}-ndevices ] arg (=0)       &Number of devices (0=all), if supported by 
                                  FFT lib (e.g. clfft and fftw with n CPU 
                                  threads). \\
-l&[ -{}-list-devices ]            &List of available compute devices with IDs,
                                  if supported.  \\
-b&[ -{}-list-benchmarks ]         &Show registered benchmarks \\
-r&[ -{}-run-benchmarks ] arg      &Run specific benchmarks (wildcards 
                                  possible, e.g. ClFFT/float/*/Inplace\_Real)\\
\bottomrule
  \end{tabular}
\end{table}

For the command-line arguments Boost is utilized, particularly for benchmark lists and selection. The \gearshifft{} program options are given in \cref{tab:cmdargs}.\linebreak
\verb!gearshifft_clfft -e 16,16 8x8x8 -r */float/*/Inplace_Real -d cpu!\linebreak
would run clfft benchmarks with real inplace real-to-complex / complex-to-real transform on an $8\times8\times8$ FFT and $16\times16$ FFT at single-precision. The default setting implies to use all CPU cores and to dump the results to result.csv (if already existent, it will be overwritten).
The first wildcard \mc{*} relates to the title of the FFT client, where the second one refers to the extents.

