
% - [open source] framework: c++14 with help of boost
% - demonstrate usage of gearshifft framework
% - cufft, clfft, fftw
% - issues?
% - #runs, cmake, project structure
% - libraries : mem checks

\gearshifft{} is developed as an open-source framework using C++14 standard and Boost Unit Test Framework for managing the benchmark trees.
The frontend API is basically just a wrapper mapping the use case explained in \cref{sec:motivation}.
This interface is designed to integrate any given FFT library, that provides forward and backward Fourier transforms.
The wrapper code leverages C++ templates and compile-time constant expressions.
This yields minimal overhead at runtime and provides a type-agnostic interface, i.\,e. it is not fixed to single or double precision.
However, corresponding timer calls and benchmark routines for collecting data are required at runtime, so measurements will have to be verified.

The frontend interface requires the user to implement the context class and a class with implementation of FFT routines.
The context class in \cref{lst:implcontext} is instantiated only once for the application lifetime.
FFT implementation class in \cref{lst:implfft} is instantiated once per benchmark run and follows the ``resource allocation is initialization'' (RAII) pattern.


\begin{lstlisting}[caption={Context class required by gearshifft API},label={lst:implcontext}]
struct Context {
  /// title for all benchmarks
  static std::string title();
  /// list all compute devices
  static std::string get_device_list();
  /// information for current device
  std::string get_used_device_properties();
  /// creates context
  void create();
  /// destroys context
  void destroy();
};
\end{lstlisting}
\begin{lstlisting}[caption={FFT class required by gearshifft API},label={lst:implfft}]
template<
 typename TFFT, // e.g. gearshifft::FFT_Inplace_Real, ...
 typename TPrecision, // e.g. double, float, ...
 size_t   NDim        // 1,..,3
>
struct MyImpl {
  MyImpl();
  ~MyImpl();
  void allocate();
  size_t getAllocSize();
  size_t getTransferSize();
  size_t getPlanSize();
  void init_forward();
  void init_inverse();
  void execute_forward();
  void execute_inverse();
  template<typename THostData>
  void upload(THostData* input);
  template<typename THostData>
  void download(THostData* output);
  void destroy();
};
\end{lstlisting}
\begin{lstlisting}[caption={Using FFT class},label={lst:implfftusing}]
using Inplace_Real =
 gearshifft::FFT<gearshifft::FFT_Inplace_Real, MyImpl, TimerCPU>;
\end{lstlisting}

The wrapper for the user FFT class and the layout of measurement is given in the \lstinline!gearshifft::FFT! class.
Its are shown in \cref{lst:fftabstract}. The measurement framework is illustrated in \cref{fig:timings}.
\begin{lstlisting}[caption={FFT wrapper class},label={lst:fftabstract}]
template<
 typename TFFT,
 template <typename,typename,size_t,typename... > typename TPlan,
 typename TDeviceTimer,
 typename... TPlanArgs // is redirected to TPlan
>
struct FFT : public TFFT {
  template<typename T_Result, typename T_Vector, size_t NDim>
  void operator(/*..*/);
};
\end{lstlisting}

% implies plan reuse
\begin{figure}\label{fig:timings}
\centering
%align=center,rounded corners,inner sep=5pt,rectangle,draw,
\tikzset{class/.style={inner sep=5pt,font=\footnotesize}}
\newcommand{\pclass}[5][]{
\ifthenelse { \equal {#1} {} }
 {\node[class] (#5) at (#3,#4) {#2};}
 {\node[class] (#5) at (#3,#4) {%
\begin{tabular}{c}\scriptsize{<<#1>>}\\#2\end{tabular}%
};}
}
\begin{tikzpicture}
\tikzset{gr1/.style={fill=black!15}}
\tikzset{bts/.style={draw,circle,inner sep=2pt}}
\tikzset{btc/.style={draw,circle,inner sep=2pt,fill=black}}
%
\begin{scope}[yshift=3.5cm,xshift=-2.9cm]
\node[bts] (b0) at (0,0) {};
\node[bts] (b10) at (-0.5,-0.6) {}; \draw (b10) -- (b0);
\node[bts] (b11) at (0.5,-0.6) {}; \draw (b11) -- (b0);
\node[btc] (b20) at (-0.75,-1.3) {}; \draw (b20) -- (b10);
\node[btc] (b21) at (-0.25,-1.3) {}; \draw (b21) -- (b10);
\node[btc] (b22) at ( 0.25,-1.3) {}; \draw (b22) -- (b11);
\node[btc] (b23) at ( 0.75,-1.3) {}; \draw (b23) -- (b11);
\node[font=\scriptsize] at (0, 0.3) {Boost Test Suites};
\node[font=\scriptsize] at (0,-1.7) {Boost Test Cases};
\end{scope}
% 
\begin{scope}[xshift=2cm]
\begin{scope}
\pclass{Benchmark}{-2}{4}{b}
\pclass[Functor]{BenchmarkSuite}{-2}{3.2}{bs}
\pclass[Functor]{BenchmarkExecutor}{-2}{2.1}{be}
\pclass[Functor]{FFT}{-2}{1.0}{fft}
\end{scope}
\begin{scope}
\pclass[Singleton]{Application}{1.5}{4}{app}
\pclass[Realisation]{Context}{1.5}{2.5}{ctx}
\pclass[Realisation]{FFTClient}{1.5}{1.1}{impl}
\end{scope}
\end{scope}
\matrix[
 minimum height=1.5em,
 matrix of nodes,
 row sep=-\pgflinewidth,
 column sep=-\pgflinewidth,
 text depth=2.5ex,
 text height=1.5ex,
 text width=3.6em,
 align=center,
 nodes in empty cells,
 row 1/.style={nodes={rectangle,draw,minimum width=3em,font=\scriptsize}}
]
(mf) at (0,0) {
allocate &
init\linebreak forward &
|[gr1]| upload &
|[gr1]| execute\linebreak forward &
init\linebreak inverse &
|[gr1]| execute\linebreak inverse &
|[gr1]| download &
destroy\\
};
\draw (mf-1-1.north west) ++(-0.75em,0.5em) coordinate (ctl) -- ([xshift=0.75em,yshift=0.5em]mf-1-8.north east) coordinate (cr);
\draw[dotted] (ctl) -- ++(-2ex,0); \draw[dotted] (cr) -- ++(2ex,0);
\draw (mf-1-1.south west) ++(-0.75em,-0.5em) coordinate (cl) -- ([xshift=0.75em,yshift=-0.5em]mf-1-8.south east) coordinate (cr);
\draw[dotted] (cl) -- ++(-2ex,0); \draw[dotted] (cr) -- ++(2ex,0);
% total time
\draw[thick,dashed,|-|] (mf-1-1.south west) ++(0,-1.5em) -- ([yshift=-1.5em]mf-1-8.south east) node[pos=0.5,fill=white,font=\small\itshape] {total time};
% (mf-1-1.south west) -- ++(0,-1.5em) -| (mf-1-8.south east) node[pos=0.25,fill=white,font=\small] {total time};

% \draw[-latex] (b) -- (bs);
% \draw[-latex] (fft) -- (ctl-|fft);
\draw[black!50] (b.south west) -- (b.south east);
\draw[black!50] (bs.south west) -- (bs.south east);
\draw[black!50, dashed] (bs.south west) -- ++(-8em,0); % test suite marker
\draw[black!50] (be.south west) -- (be.south east);

\draw[densely dashed,-angle 60] (app) -- (ctx);
\draw[-angle 60] (b) -- (app.west|-b);
% \draw[densely dashed,-angle 90] (be.east) -| (impl.north);
% \draw[densely dashed,-open triangle 60] (impl) -- (fft.east|-impl) node[midway] (q) {};
\draw[densely dashed,-angle 90] (fft) -- (impl.west|-fft) node[midway] (q) {};
\draw[densely dashed] (q) -- (ctl-|q);
\end{tikzpicture}
 \caption{The benchmark framework of \gearshifft{} using Boost UTF and a realised FFT interface; Here only FFT interfaces are shown, that are measured (gray operations are measured by device timers if required); Context also has an implicit interface, which is omitted here.}
\end{figure}


The backend of \gearshifft{} uses Boost Unit Test Framework to manage the benchmark instances.

